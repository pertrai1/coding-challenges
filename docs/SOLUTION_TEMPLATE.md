## 1. Problem Restatement (In your own words)

## 2. Constraints & Edge Cases

- ## **Constraints:**

- ## **Edge Cases:**

## 3. Data Structures & Patterns

- **Data Structures:**
- **Algorithmic Patterns:**

## 4. Intuition

(High-level reasoning before coding)

## 5. Approach

(Step-by-step plan)

## 6. Solution Walkthrough

| Input     | Steps & State Changes | Output |
| --------- | --------------------- | ------ |
| `[1,2,3]` | …                     | …      |

## 7. Test Cases & Results

| Test Case      | Expected | Actual | Notes               |
| -------------- | -------- | ------ | ------------------- |
| `[]`           | `0`      | `0`    | Handled empty input |
| `[-1, -2, -3]` | …        | …      |                     |

## 8. Complexity Analysis

- **Time Complexity:** O(n log n)
- **Space Complexity:** O(n)

## 9. Mistakes & Pitfalls

- **Issue:** Initial bug with null inputs
- **Discovery:** Runtime error on test case X
- **Fix:** Added guard clause

## 10. Alternate Approaches

- **Approach A:** BFS (O(V + E), higher memory)
- **Approach B:** Divide-and-conquer (trade-off details)

## 11. Key Takeaways

- Learned that a monotonic stack simplifies this pattern
- Watch for off-by-one in index calculations
