name: Schedule Spaced Repetition Review

on:
  pull_request:
    types: [closed]
    branches: [main]

permissions:
  contents: write
  pull-requests: write

jobs:
  schedule-review:
    runs-on: ubuntu-latest
    # Only run if PR was merged (not just closed)
    if: github.event.pull_request.merged == true && github.event.pull_request.user.login == 'pertrai1'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Extract problem information
        id: extract-info
        env:
          PR_TITLE: ${{ github.event.pull_request.title }}
        run: |
          # Get PR information
          PR_NUMBER="${{ github.event.pull_request.number }}"
          PR_URL="${{ github.event.pull_request.html_url }}"
          MERGED_AT="${{ github.event.pull_request.merged_at }}"

          # Get changed files - only match actual solution files from coding challenge platforms
          git fetch origin main
          CHANGED_FILES=$(git diff --name-only "${{ github.event.pull_request.base.sha }}..${{ github.event.pull_request.head.sha }}" | grep -E '(leetcode/(easy|medium|hard)/[0-9]+-[^/]+|greatfrontend/[^/]+/[^/]+(/[^/]+)*)/[^/]+\.(js|ts)$' || echo "")

          echo "pr_title=$PR_TITLE" >> $GITHUB_OUTPUT
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT
          echo "merged_at=$MERGED_AT" >> $GITHUB_OUTPUT

          # Use delimiter for multi-line output
          {
            echo "changed_files<<EOF"
            echo "$CHANGED_FILES"
            echo "EOF"
          } >> $GITHUB_OUTPUT

          echo "ðŸ“‹ PR Info:"
          echo "Title: $PR_TITLE"
          echo "Number: $PR_NUMBER"
          echo "Merged at: $MERGED_AT"
          echo "Changed files: $CHANGED_FILES"
      - name: Parse problem details
        id: parse-problem
        run: |
          CHANGED_FILES="${{ steps.extract-info.outputs.changed_files }}"

          if [ -z "$CHANGED_FILES" ]; then
            echo "âš ï¸ No coding challenge files changed in this PR"
            echo "has_challenge_files=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "has_challenge_files=true" >> $GITHUB_OUTPUT

          # Find the main solution file (should match problem slug in filename)
          MAIN_FILE=""
          PLATFORM=""
          for file in $CHANGED_FILES; do
            # Extract problem info from file path first
            # Example: leetcode/easy/0205-isomorphic-strings/isomorphic-strings.js
            # Example: greatfrontend/blind-75/array/most-common-elements/most-common-elements.js
            if [[ "$file" =~ leetcode/([^/]+)/([0-9]+)-([^/]+)/([^/]+)\.(js|ts)$ ]]; then
              PLATFORM="leetcode"
              DIFFICULTY="${BASH_REMATCH[1]}"
              PROBLEM_NUMBER="${BASH_REMATCH[2]}"
              PROBLEM_SLUG="${BASH_REMATCH[3]}"
              FILE_NAME="${BASH_REMATCH[4]}"

              # Validate that the filename matches the problem slug (main solution file)
              # Exclude test files explicitly
              if [[ "$FILE_NAME" == "$PROBLEM_SLUG" ]] && [[ ! "$FILE_NAME" =~ \.test$ ]]; then
                MAIN_FILE="$file"
                echo "main_file=$MAIN_FILE" >> $GITHUB_OUTPUT
                echo "platform=$PLATFORM" >> $GITHUB_OUTPUT
                break
              fi
            elif [[ "$file" =~ greatfrontend/([^/]+)/([^/]+)/(([^/]+)/)?([^/]+)/([^/]+)\.(js|ts)$ ]]; then
              # Match: greatfrontend/[category]/[topic]/[problem-folder]/[problem-file].ts
              # OR: greatfrontend/[category]/[problem-folder]/[problem-file].ts
              PLATFORM="greatfrontend"
              CATEGORY="${BASH_REMATCH[1]}"  # blind-75, gfe-75, etc.
              TOPIC="${BASH_REMATCH[2]}"     # array, javascript-utilities, etc.
              PROBLEM_FOLDER="${BASH_REMATCH[5]}"  # most-common-elements, flatten, etc.
              FILE_NAME="${BASH_REMATCH[6]}"

              # Validate that the filename matches the problem folder (main solution file)
              if [[ "$FILE_NAME" == "$PROBLEM_FOLDER" ]] && [[ ! "$FILE_NAME" =~ \.test$ ]]; then
                MAIN_FILE="$file"
                PROBLEM_SLUG="$PROBLEM_FOLDER"
                # Use category/topic as difficulty indicator
                DIFFICULTY="$CATEGORY/$TOPIC"
                # Extract problem number from folder name if it exists
                if [[ "$PROBLEM_FOLDER" =~ ^([0-9]+)- ]]; then
                  PROBLEM_NUMBER="${BASH_REMATCH[1]}"
                else
                  # Use a placeholder for problems without numbers
                  PROBLEM_NUMBER="GFE-$(echo $PROBLEM_FOLDER | md5sum | cut -c1-4)"
                fi
                echo "main_file=$MAIN_FILE" >> $GITHUB_OUTPUT
                echo "platform=$PLATFORM" >> $GITHUB_OUTPUT
                break
              fi
            fi
          done

          if [[ -z "$MAIN_FILE" ]]; then
            echo "âš ï¸ No main solution file found matching expected pattern"
            echo "has_challenge_files=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Extract problem info from validated main file (already set in the loop above)
          if [[ -n "$MAIN_FILE" ]]; then
            echo "platform=$PLATFORM" >> $GITHUB_OUTPUT
            echo "difficulty=$DIFFICULTY" >> $GITHUB_OUTPUT
            echo "problem_number=$PROBLEM_NUMBER" >> $GITHUB_OUTPUT
            echo "problem_slug=$PROBLEM_SLUG" >> $GITHUB_OUTPUT

            # Create human-readable problem name
            PROBLEM_NAME=$(echo "$PROBLEM_SLUG" | sed 's/-/ /g' | sed 's/\b\(.\)/\u\1/g')
            echo "problem_name=$PROBLEM_NAME" >> $GITHUB_OUTPUT

            echo "âœ… Parsed problem: $PLATFORM #$PROBLEM_NUMBER - $PROBLEM_NAME ($DIFFICULTY)"
          else
            echo "âš ï¸ File doesn't match expected pattern: $MAIN_FILE"
            echo "has_challenge_files=false" >> $GITHUB_OUTPUT
          fi

      - name: Add to review schedule
        if: steps.parse-problem.outputs.has_challenge_files == 'true'
        run: |
          node << 'EOF'
          const fs = require('fs');
          const path = require('path');

          // Read current schedule
          const schedulePath = 'docs/reviews/review-schedule.json';
          let schedule = JSON.parse(fs.readFileSync(schedulePath, 'utf8'));

          // Problem details
          const problemData = {
            platform: '${{ steps.parse-problem.outputs.platform }}',
            problemNumber: '${{ steps.parse-problem.outputs.problem_number }}',
            problemName: '${{ steps.parse-problem.outputs.problem_name }}',
            problemSlug: '${{ steps.parse-problem.outputs.problem_slug }}',
            difficulty: '${{ steps.parse-problem.outputs.difficulty }}',
            prNumber: '${{ steps.extract-info.outputs.pr_number }}',
            prUrl: '${{ steps.extract-info.outputs.pr_url }}',
            filePath: '${{ steps.parse-problem.outputs.main_file }}',
            solvedDate: '${{ steps.extract-info.outputs.merged_at }}',
            reviewsDue: [],
            reviewsCompleted: []
          };

          // Only schedule the first review initially
          // Subsequent reviews will be scheduled when previous ones are completed
          const solvedDate = new Date(problemData.solvedDate);
          const intervals = schedule.reviewIntervals; // [1, 3, 7, 14, 30]

          // Schedule only the first review (1 day after solving)
          const firstReviewDate = new Date(solvedDate);
          firstReviewDate.setDate(firstReviewDate.getDate() + intervals[0]);

          problemData.reviewsDue.push({
            reviewNumber: 1,
            scheduledDate: firstReviewDate.toISOString().split('T')[0],
            interval: intervals[0],
            completed: false,
            issueNumber: null
          });

          console.log(`Scheduled first review for ${firstReviewDate.toISOString().split('T')[0]}`);
          console.log(`Remaining reviews will be scheduled upon completion of previous reviews`);

          // Add to schedule
          schedule.problems.push(problemData);
          schedule.lastUpdated = new Date().toISOString();

          // Write updated schedule
          fs.writeFileSync(schedulePath, JSON.stringify(schedule, null, 2));

          console.log('âœ… Added problem to review schedule:');
          console.log(`   Problem: ${problemData.problemName}`);
          console.log(`   First review scheduled: ${problemData.reviewsDue[0].scheduledDate}`);
          console.log(`   Total reviews planned: ${intervals.length}`);
          EOF

      - name: Commit updated schedule
        if: steps.parse-problem.outputs.has_challenge_files == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          if [ -n "$(git status --porcelain docs/reviews/)" ]; then
            # Switch to main branch to ensure push succeeds for all merge strategies
            echo "ðŸ“¡ Fetching latest main branch..."
            git fetch origin main
            git checkout main
            git pull origin main

            # Stage and commit the changes
            git add docs/reviews/review-schedule.json
            git commit -m "ðŸ“… Schedule spaced repetition reviews for ${{ steps.parse-problem.outputs.problem_name }}

            Problem: #${{ steps.parse-problem.outputs.problem_number }} - ${{ steps.parse-problem.outputs.problem_name }}
            PR: #${{ steps.extract-info.outputs.pr_number }}
            First review scheduled (subsequent reviews auto-scheduled on completion)

            [skip ci]"

            git push origin main
            echo "âœ… Review schedule updated and pushed"
          else
            echo "â„¹ï¸ No changes to commit"
          fi

      - name: Comment on PR
        if: steps.parse-problem.outputs.has_challenge_files == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const comment = `## ðŸ“… Spaced Repetition Reviews Scheduled!

            Great job solving **#${{ steps.parse-problem.outputs.problem_number }} - ${{ steps.parse-problem.outputs.problem_name }}**! ðŸŽ‰

            To help you retain this knowledge long-term, I've scheduled **5 review sessions** using spaced repetition:

            | Review | Interval | Schedule Logic |
            |--------|----------|----------------|
            | 1st Review | 1 day after solving | Scheduled now |
            | 2nd Review | 3 days after 1st review | Auto-scheduled when 1st completes |
            | 3rd Review | 7 days after 2nd review | Auto-scheduled when 2nd completes |
            | 4th Review | 14 days after 3rd review | Auto-scheduled when 3rd completes |
            | 5th Review | 30 days after 4th review | Auto-scheduled when 4th completes |

            ### What to expect:
            - Your **1st review** is scheduled for tomorrow
            - Each subsequent review is scheduled **automatically** when you complete the previous one
            - This ensures proper spacing even if you complete a review a few days late
            - GitHub issues will be created automatically for each review
            - Each issue will link back to your solution

            ### ðŸ§  Why Spaced Repetition?
            Research shows that reviewing material at increasing intervals dramatically improves retention. This adaptive scheduling ensures optimal spacing based on when you *actually* complete each review!

            _Check \`docs/reviews/review-schedule.json\` to see your review schedule._`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ steps.extract-info.outputs.pr_number }},
              body: comment
            });
