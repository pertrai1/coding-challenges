name: Coding Challenge Mentor

on:
  pull_request:
    types: [opened, synchronize, labeled]
    paths:
      - 'leetcode/**'
      - 'greatfrontend/**'
      - '*-*/**'

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  mentor:
    runs-on: ubuntu-latest
    if: github.actor == 'pertrai1' && contains(github.event.pull_request.labels.*.name, 'code challenge')
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Extract Problem Info
        id: problem
        run: |
          # Get files changed in this PR
          PROBLEM_PATH=$(git diff --name-only origin/${{ github.base_ref }}...HEAD | grep -E '(leetcode|greatfrontend|[0-9]+-[a-zA-Z0-9-]+)' | head -1)

          if [ -z "$PROBLEM_PATH" ]; then
            echo "No coding challenge files found"
            echo "found=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "found=true" >> $GITHUB_OUTPUT
          echo "path=$PROBLEM_PATH" >> $GITHUB_OUTPUT

          # Determine platform
          if echo "$PROBLEM_PATH" | grep -q "^leetcode/"; then
            PLATFORM="LeetCode"
          elif echo "$PROBLEM_PATH" | grep -q "^greatfrontend/"; then
            PLATFORM="GreatFrontEnd"
          else
            PLATFORM="Unknown"
          fi
          echo "platform=$PLATFORM" >> $GITHUB_OUTPUT

          # Extract difficulty from path (leetcode/easy/, leetcode/medium/, leetcode/hard/)
          if echo "$PROBLEM_PATH" | grep -q "leetcode/easy"; then
            DIFFICULTY="Easy"
          elif echo "$PROBLEM_PATH" | grep -q "leetcode/medium"; then
            DIFFICULTY="Medium"
          elif echo "$PROBLEM_PATH" | grep -q "leetcode/hard"; then
            DIFFICULTY="Hard"
          elif echo "$PROBLEM_PATH" | grep -q "greatfrontend"; then
            DIFFICULTY="Varies"
          else
            DIFFICULTY="Unknown"
          fi
          echo "difficulty=$DIFFICULTY" >> $GITHUB_OUTPUT

          # Extract problem number and name
          # Pattern: 0001-two-sum or 1034-subarrays-with-k-different-integers
          PROBLEM_FOLDER=$(echo "$PROBLEM_PATH" | grep -oE '[0-9]+-[a-zA-Z0-9-]+' | head -1)
          if [ -n "$PROBLEM_FOLDER" ]; then
            PROBLEM_NUM=$(echo "$PROBLEM_FOLDER" | grep -oE '^[0-9]+')
            PROBLEM_NAME=$(echo "$PROBLEM_FOLDER" | sed 's/^[0-9]*-//' | tr '-' ' ' | sed 's/\b\(.\)/\u\1/g')
          else
            # For non-numbered problems (e.g., GreatFrontEnd)
            PROBLEM_NUM=""
            PROBLEM_NAME=$(basename $(dirname "$PROBLEM_PATH") | tr '-' ' ' | sed 's/\b\(.\)/\u\1/g')
          fi

          echo "problem_num=$PROBLEM_NUM" >> $GITHUB_OUTPUT
          echo "problem_name=$PROBLEM_NAME" >> $GITHUB_OUTPUT
          echo "problem_folder=$PROBLEM_FOLDER" >> $GITHUB_OUTPUT

      - name: Read Solution File
        if: steps.problem.outputs.found == 'true'
        id: solution
        run: |
          # Find the solution file
          PROBLEM_PATH="${{ steps.problem.outputs.path }}"
          SOLUTION_DIR=$(dirname "$PROBLEM_PATH")

          # Look for .js or .ts solution file
          SOLUTION_FILE=$(find "$SOLUTION_DIR" -maxdepth 1 -type f \( -name "*.js" -o -name "*.ts" \) ! -name "*.test.*" ! -name "*.spec.*" | head -1)

          if [ -n "$SOLUTION_FILE" ] && [ -f "$SOLUTION_FILE" ]; then
            echo "file=$SOLUTION_FILE" >> $GITHUB_OUTPUT
            # Read the entire solution file content
            SOLUTION_CONTENT=$(cat "$SOLUTION_FILE")
            # Save to file for Node.js script to read
            cat "$SOLUTION_FILE" > solution-content.txt
            echo "Solution file found and content saved"
          else
            echo "No solution file found"
            echo "" > solution-content.txt
          fi

      - name: Setup Node.js
        if: steps.problem.outputs.found == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Generate Learning Card
        if: steps.problem.outputs.found == 'true'
        id: learning_card
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          PLATFORM: ${{ steps.problem.outputs.platform }}
          PROBLEM_NUM: ${{ steps.problem.outputs.problem_num }}
          PROBLEM_NAME: ${{ steps.problem.outputs.problem_name }}
          DIFFICULTY: ${{ steps.problem.outputs.difficulty }}
          FILE_PATH: ${{ steps.problem.outputs.path }}
          SOLUTION_FILE: ${{ steps.solution.outputs.file }}
        run: |
          node << 'SCRIPT_EOF'
          const fs = require('fs');
          const https = require('https');

          // Read solution content
          const solutionContent = fs.readFileSync('solution-content.txt', 'utf8');
          const platform = process.env.PLATFORM || 'Unknown';
          const problemNum = process.env.PROBLEM_NUM || '';
          const problemName = process.env.PROBLEM_NAME || '';
          const difficulty = process.env.DIFFICULTY || 'Unknown';
          const filePath = process.env.FILE_PATH || '';
          const hasOpenAI = !!process.env.OPENAI_API_KEY;

          // Pattern detection heuristics
          function detectPatterns(code) {
            const patterns = [];
            const dataStructures = [];
            const techniques = [];
            
            // Detect common patterns
            if (/\bleft\b.*\bright\b|\bright\b.*\bleft\b/i.test(code) && /while|for/.test(code)) {
              if (/\.add\(|\.has\(|\.delete\(|new Set|new Map/.test(code)) {
                patterns.push('Sliding Window');
              } else {
                patterns.push('Two Pointers');
              }
            }
            
            if (/dp\[|memo\[|cache\[|new Array.*fill/i.test(code)) {
              patterns.push('Dynamic Programming');
            }
            
            if (/new Queue|queue\.push|queue\.shift|\.shift\(\).*while|BFS/i.test(code) || 
                (/queue/.test(code) && /shift|unshift/.test(code))) {
              patterns.push('BFS (Breadth-First Search)');
            }
            
            if (/function.*dfs|const.*dfs|\.dfs\(|DFS|recursion/i.test(code) || 
                (/function \w+\(/.test(code) && /\1\(/.test(code))) {
              patterns.push('DFS (Depth-First Search)');
            }
            
            if (/new Map|\.get\(|\.set\(|new Set|\.add\(|\.has\(/i.test(code)) {
              patterns.push('Hash Table');
            }
            
            if (/\.sort\(|quicksort|mergesort|heapsort/i.test(code)) {
              patterns.push('Sorting');
            }
            
            if (/greedy|maxHeap|minHeap|PriorityQueue/i.test(code)) {
              patterns.push('Greedy');
            }
            
            if (/stack\.push|stack\.pop|new.*Stack|\[\]\.push.*\.pop/i.test(code)) {
              patterns.push('Stack');
            }
            
            if (/heap|priority.*queue|PriorityQueue/i.test(code)) {
              patterns.push('Heap');
            }
            
            if (/trie|TrieNode|prefix.*tree/i.test(code)) {
              patterns.push('Trie');
            }
            
            if (/union.*find|disjoint.*set|parent\[|rank\[/i.test(code)) {
              patterns.push('Union-Find');
            }
            
            if (/<<|>>|&|\||\^|~|\bxor\b/i.test(code) && !/&&|\|\|/.test(code)) {
              patterns.push('Bit Manipulation');
            }
            
            if (/binary.*search|left.*<=.*right|mid.*=.*Math\.floor/i.test(code)) {
              patterns.push('Binary Search');
            }
            
            if (/backtrack|permutation|combination|subset/i.test(code)) {
              patterns.push('Backtracking');
            }
            
            if (/prefix.*sum|cumulative|running.*sum/i.test(code)) {
              techniques.push('Prefix Sum');
            }
            
            if (/monotonic|increasing.*stack|decreasing.*stack/i.test(code)) {
              techniques.push('Monotonic Stack');
            }
            
            // Data structure detection
            if (/new Map|Map\(/.test(code)) dataStructures.push('Map');
            if (/new Set|Set\(/.test(code)) dataStructures.push('Set');
            if (/new Array|\[\]/.test(code)) dataStructures.push('Array');
            if (/\.push\(.*\.pop\(|stack/i.test(code)) dataStructures.push('Stack');
            if (/\.push\(.*\.shift\(|queue/i.test(code)) dataStructures.push('Queue');
            if (/TreeNode|\.left|\.right|tree/i.test(code)) dataStructures.push('Binary Tree');
            if (/ListNode|\.next|linked.*list/i.test(code)) dataStructures.push('Linked List');
            if (/graph\[|adjacency|edges/i.test(code)) dataStructures.push('Graph');
            if (/heap|priority/i.test(code)) dataStructures.push('Heap');
            
            return {
              primary: patterns[0] || 'Unknown Pattern',
              secondary: patterns.slice(1),
              techniques,
              dataStructures: [...new Set(dataStructures)]
            };
          }

          // Extract complexity from comments
          function extractComplexity(code) {
            const timeMatch = code.match(/(?:time|@time)[:\s]*O\([^)]+\)/i);
            const spaceMatch = code.match(/(?:space|@space)[:\s]*O\([^)]+\)/i);
            return {
              time: timeMatch ? timeMatch[0].replace(/.*O\(/i, 'O(') : null,
              space: spaceMatch ? spaceMatch[0].replace(/.*O\(/i, 'O(') : null
            };
          }

          // Infer complexity based on code patterns
          function inferComplexity(code, patterns) {
            let time = 'O(n)';
            let space = 'O(1)';
            
            const nestedLoops = (code.match(/for|while/g) || []).length;
            if (nestedLoops >= 3) time = 'O(nÂ³)';
            else if (nestedLoops >= 2) time = 'O(nÂ²)';
            
            if (/\.sort\(/.test(code)) time = 'O(n log n)';
            if (/binary.*search/i.test(code) && nestedLoops < 2) time = 'O(log n)';
            
            if (/new Map|new Set|dp\[|memo\[|new Array/.test(code)) space = 'O(n)';
            if (/recursion|function.*\(/.test(code) && code.includes('return')) {
              space = 'O(n) - recursion stack';
            }
            
            return { time, space };
          }

          // Generate key insight based on pattern
          function generateKeyInsight(primaryPattern, code) {
            const insights = {
              'Sliding Window': 'Use two pointers to maintain a dynamic window that expands and contracts, avoiding the need to recalculate the entire subarray each time. This transforms a brute force O(nÂ²) solution into O(n).',
              'Two Pointers': 'Start with pointers at different positions and move them towards each other (or in the same direction) based on conditions. This eliminates the need for nested loops, reducing time complexity from O(nÂ²) to O(n).',
              'Dynamic Programming': 'Break the problem into overlapping subproblems and store solutions to avoid redundant calculations. The key is identifying the recurrence relation and base cases, then building the solution bottom-up or top-down with memoization.',
              'BFS (Breadth-First Search)': 'Explore nodes level by level using a queue. BFS guarantees the shortest path in unweighted graphs and is ideal for problems requiring layer-by-layer exploration.',
              'DFS (Depth-First Search)': 'Explore as deep as possible along each branch before backtracking. DFS is memory efficient for deep trees and useful for path finding, cycle detection, and topological sorting.',
              'Hash Table': 'Use a Map or Set to achieve O(1) lookups, enabling you to trade space for time. This is essential for complement searches, frequency counting, and duplicate detection.',
              'Binary Search': 'When the search space is sorted or can be partitioned, use binary search to eliminate half the possibilities at each step, achieving O(log n) time complexity.',
              'Backtracking': 'Build solutions incrementally and abandon paths that cannot lead to a valid solution. This systematic exploration is key for generating permutations, combinations, and solving constraint satisfaction problems.',
              'Stack': 'LIFO (Last In First Out) structure is perfect for matching pairs, tracking history, and problems requiring most recent element access. Essential for parsing, expression evaluation, and monotonic stack problems.',
              'Greedy': 'Make locally optimal choices at each step, hoping to find a global optimum. The key insight is proving that the greedy choice property holds for the problem.',
              'Union-Find': 'Efficiently track and merge disjoint sets. The path compression and union by rank optimizations achieve near-constant time operations, making it ideal for connectivity and grouping problems.',
              'Trie': 'Build a tree where each path from root to leaf represents a word or prefix. This enables efficient prefix matching and autocomplete features with O(m) complexity where m is the word length.',
              'Bit Manipulation': 'Manipulate individual bits using bitwise operators for space-efficient solutions. Common tricks include using XOR for finding unique elements and bit masks for representing sets.',
            };
            
            return insights[primaryPattern] || 'Identify the core algorithmic approach that transforms a naive solution into an efficient one. Look for patterns in how the code avoids redundant work or leverages specific data structure properties.';
          }

          // Generate related problems based on pattern
          function generateRelatedProblems(primaryPattern) {
            const problemMap = {
              'Sliding Window': [
                { id: '3', name: 'Longest Substring Without Repeating Characters', level: 'Similar' },
                { id: '76', name: 'Minimum Window Substring', level: 'Harder' },
                { id: '209', name: 'Minimum Size Subarray Sum', level: 'Similar' },
                { id: '438', name: 'Find All Anagrams in a String', level: 'Similar' },
                { id: '567', name: 'Permutation in String', level: 'Similar' }
              ],
              'Two Pointers': [
                { id: '167', name: 'Two Sum II - Input Array Is Sorted', level: 'Easier' },
                { id: '15', name: 'Three Sum', level: 'Similar' },
                { id: '11', name: 'Container With Most Water', level: 'Similar' },
                { id: '42', name: 'Trapping Rain Water', level: 'Harder' },
                { id: '283', name: 'Move Zeroes', level: 'Easier' }
              ],
              'Dynamic Programming': [
                { id: '70', name: 'Climbing Stairs', level: 'Easier' },
                { id: '198', name: 'House Robber', level: 'Similar' },
                { id: '322', name: 'Coin Change', level: 'Similar' },
                { id: '300', name: 'Longest Increasing Subsequence', level: 'Similar' },
                { id: '1143', name: 'Longest Common Subsequence', level: 'Similar' }
              ],
              'BFS (Breadth-First Search)': [
                { id: '102', name: 'Binary Tree Level Order Traversal', level: 'Easier' },
                { id: '200', name: 'Number of Islands', level: 'Similar' },
                { id: '127', name: 'Word Ladder', level: 'Harder' },
                { id: '994', name: 'Rotting Oranges', level: 'Similar' },
                { id: '542', name: '01 Matrix', level: 'Similar' }
              ],
              'DFS (Depth-First Search)': [
                { id: '200', name: 'Number of Islands', level: 'Similar' },
                { id: '78', name: 'Subsets', level: 'Similar' },
                { id: '46', name: 'Permutations', level: 'Similar' },
                { id: '101', name: 'Symmetric Tree', level: 'Easier' },
                { id: '124', name: 'Binary Tree Maximum Path Sum', level: 'Harder' }
              ],
              'Hash Table': [
                { id: '1', name: 'Two Sum', level: 'Easier' },
                { id: '49', name: 'Group Anagrams', level: 'Similar' },
                { id: '128', name: 'Longest Consecutive Sequence', level: 'Similar' },
                { id: '146', name: 'LRU Cache', level: 'Harder' },
                { id: '560', name: 'Subarray Sum Equals K', level: 'Similar' }
              ],
              'Binary Search': [
                { id: '704', name: 'Binary Search', level: 'Easier' },
                { id: '33', name: 'Search in Rotated Sorted Array', level: 'Similar' },
                { id: '153', name: 'Find Minimum in Rotated Sorted Array', level: 'Similar' },
                { id: '4', name: 'Median of Two Sorted Arrays', level: 'Harder' },
                { id: '35', name: 'Search Insert Position', level: 'Easier' }
              ],
              'Backtracking': [
                { id: '78', name: 'Subsets', level: 'Similar' },
                { id: '46', name: 'Permutations', level: 'Similar' },
                { id: '22', name: 'Generate Parentheses', level: 'Similar' },
                { id: '51', name: 'N-Queens', level: 'Harder' },
                { id: '39', name: 'Combination Sum', level: 'Similar' }
              ],
              'Stack': [
                { id: '20', name: 'Valid Parentheses', level: 'Easier' },
                { id: '155', name: 'Min Stack', level: 'Similar' },
                { id: '739', name: 'Daily Temperatures', level: 'Similar' },
                { id: '84', name: 'Largest Rectangle in Histogram', level: 'Harder' },
                { id: '503', name: 'Next Greater Element II', level: 'Similar' }
              ],
              'Greedy': [
                { id: '55', name: 'Jump Game', level: 'Similar' },
                { id: '45', name: 'Jump Game II', level: 'Similar' },
                { id: '134', name: 'Gas Station', level: 'Similar' },
                { id: '763', name: 'Partition Labels', level: 'Similar' },
                { id: '435', name: 'Non-overlapping Intervals', level: 'Similar' }
              ],
              'Union-Find': [
                { id: '200', name: 'Number of Islands', level: 'Similar' },
                { id: '547', name: 'Number of Provinces', level: 'Similar' },
                { id: '684', name: 'Redundant Connection', level: 'Similar' },
                { id: '721', name: 'Accounts Merge', level: 'Harder' },
                { id: '323', name: 'Number of Connected Components in an Undirected Graph', level: 'Similar' }
              ],
              'Trie': [
                { id: '208', name: 'Implement Trie (Prefix Tree)', level: 'Similar' },
                { id: '211', name: 'Design Add and Search Words Data Structure', level: 'Similar' },
                { id: '212', name: 'Word Search II', level: 'Harder' },
                { id: '648', name: 'Replace Words', level: 'Similar' },
                { id: '677', name: 'Map Sum Pairs', level: 'Similar' }
              ],
              'Bit Manipulation': [
                { id: '136', name: 'Single Number', level: 'Easier' },
                { id: '191', name: 'Number of 1 Bits', level: 'Easier' },
                { id: '338', name: 'Counting Bits', level: 'Similar' },
                { id: '268', name: 'Missing Number', level: 'Similar' },
                { id: '371', name: 'Sum of Two Integers', level: 'Similar' }
              ],
              'Heap': [
                { id: '215', name: 'Kth Largest Element in an Array', level: 'Similar' },
                { id: '347', name: 'Top K Frequent Elements', level: 'Similar' },
                { id: '23', name: 'Merge k Sorted Lists', level: 'Harder' },
                { id: '295', name: 'Find Median from Data Stream', level: 'Harder' },
                { id: '973', name: 'K Closest Points to Origin', level: 'Similar' }
              ],
              'Sorting': [
                { id: '148', name: 'Sort List', level: 'Similar' },
                { id: '56', name: 'Merge Intervals', level: 'Similar' },
                { id: '75', name: 'Sort Colors', level: 'Similar' },
                { id: '315', name: 'Count of Smaller Numbers After Self', level: 'Harder' },
                { id: '912', name: 'Sort an Array', level: 'Similar' }
              ]
            };
            
            return problemMap[primaryPattern] || [
              { id: '', name: 'Explore similar problems on LeetCode', level: 'Related' },
              { id: '', name: 'Search for problems with the same pattern', level: 'Related' }
            ];
          }

          // Generate interview tips based on pattern
          function generateInterviewTips(primaryPattern) {
            const tips = {
              'Sliding Window': [
                '**Opening**: "Let me confirm - we\'re looking for a contiguous subarray/substring, correct? Should I handle edge cases like empty input or single element?"',
                '**Brute Force â†’ Optimize**: "The brute force would check every possible window in O(nÂ²). But we can maintain a sliding window that expands when valid and contracts when invalid, reducing to O(n)."',
                '**Key Optimization**: "The insight is that we don\'t need to recalculate the entire window - we can update it incrementally by adding the new element and removing the old one."',
                '**Complexity**: "Time: O(n) with a single pass, Space: O(k) for the window state where k is the number of unique characters or elements we\'re tracking"',
                '**Edge Cases**: "I\'ll test with: empty string, single character, all unique characters, all same characters, and the exact k size"'
              ],
              'Two Pointers': [
                '**Opening**: "Is the array sorted? If not, would sorting it help? What constraints do we have on space complexity?"',
                '**Brute Force â†’ Optimize**: "A naive nested loop would be O(nÂ²). Using two pointers, we can solve this in O(n) by moving pointers based on comparisons."',
                '**Key Decision**: "The pattern is to move the left pointer when condition X is met, and right pointer when condition Y is met, converging to the solution."',
                '**Complexity**: "Time: O(n) with a single pass, Space: O(1) using only pointer variables"',
                '**Edge Cases**: "I\'ll verify with: empty array, single element, two elements, all same values, and arrays with duplicates"'
              ],
              'Dynamic Programming': [
                '**Opening**: "I notice this has overlapping subproblems and optimal substructure. Let me identify the recurrence relation."',
                '**Brute Force â†’ Optimize**: "The recursive solution has exponential time due to repeated calculations. By memoizing or using tabulation, we reduce it to polynomial time."',
                '**State Definition**: "Let dp[i] represent [explanation]. The recurrence is dp[i] = f(dp[i-1], dp[i-2], ...)"',
                '**Complexity**: "Time: O(nÃ—m) for 2D DP or O(n) for 1D, Space: O(nÃ—m) or optimized to O(n) with rolling array"',
                '**Trade-offs**: "We can use top-down (memoization) for clarity or bottom-up (tabulation) for better space optimization"'
              ],
              'BFS (Breadth-First Search)': [
                '**Opening**: "Since we need the shortest path / level-by-level processing, BFS is the right choice. Should I consider bidirectional BFS for optimization?"',
                '**Approach**: "I\'ll use a queue to explore nodes level by level, marking visited nodes to avoid cycles."',
                '**Optimization**: "For shortest path problems, BFS guarantees we find the optimal solution on the first encounter."',
                '**Complexity**: "Time: O(V + E) where V is vertices and E is edges, Space: O(V) for the queue and visited set"',
                '**Edge Cases**: "Empty graph, disconnected components, single node, cycles, and self-loops"'
              ],
              'DFS (Depth-First Search)': [
                '**Opening**: "I\'ll use DFS since we need to explore all paths / detect cycles / perform topological sort."',
                '**Iterative vs Recursive**: "I can implement this recursively for clarity or iteratively with a stack to avoid stack overflow for deep graphs."',
                '**Optimization**: "I\'ll track visited nodes to avoid redundant exploration and handle cycles."',
                '**Complexity**: "Time: O(V + E), Space: O(V) for recursion stack or explicit stack in iterative approach"',
                '**Edge Cases**: "Single node, disconnected graphs, cycles, directed vs undirected graphs"'
              ],
              'Hash Table': [
                '**Opening**: "A hash map lets me achieve O(1) lookups. What are the constraints on space? Are there duplicate values?"',
                '**Brute Force â†’ Optimize**: "Instead of nested loops O(nÂ²), I\'ll use a Map/Set to check for complements/existence in O(1)."',
                '**Key Insight**: "Store [what] in the map so that I can look up [what] in constant time."',
                '**Complexity**: "Time: O(n) with single pass, Space: O(n) for the hash map"',
                '**Edge Cases**: "Empty input, all duplicates, no solution exists, negative numbers (if applicable)"'
              ],
              'Stack': [
                '**Opening**: "The LIFO property of a stack is perfect for matching pairs / tracking most recent elements."',
                '**Pattern Recognition**: "I\'ll push elements when [condition] and pop when [condition], maintaining the invariant that [property]."',
                '**Monotonic Stack**: "For problems requiring next greater/smaller element, I\'ll maintain a monotonically increasing/decreasing stack."',
                '**Complexity**: "Time: O(n) with each element pushed and popped at most once, Space: O(n) for the stack"',
                '**Edge Cases**: "Empty input, all same elements, strictly increasing/decreasing sequences"'
              ],
              'Binary Search': [
                '**Opening**: "I notice the search space has a monotonic property, making binary search applicable. The predicate is [condition]."',
                '**Template Choice**: "I\'ll use the [standard/left-bound/right-bound] binary search template to handle [specific requirement]."',
                '**Boundary Handling**: "The key is correctly handling mid calculation and the condition for moving left vs right pointer to avoid infinite loops."',
                '**Complexity**: "Time: O(log n), Space: O(1) for iterative or O(log n) for recursive stack"',
                '**Edge Cases**: "Empty array, single element, target not found, duplicate elements, boundary values"'
              ],
              'Greedy': [
                '**Opening**: "I need to verify the greedy choice property holds - that locally optimal choices lead to a global optimum."',
                '**Proof of Correctness**: "The greedy approach works because [exchange argument / staying ahead proof]."',
                '**Algorithm**: "At each step, I\'ll choose [criterion] which is provably optimal for [reason]."',
                '**Complexity**: "Time: O(n log n) if sorting needed, O(n) otherwise, Space: O(1) or O(n) depending on sorting"',
                '**Alternative**: "If greedy doesn\'t work, I\'d fall back to DP which considers all possibilities"'
              ]
            };
            
            return tips[primaryPattern] || [
              '**Opening**: "Let me clarify the requirements and constraints. What are the expected input ranges and edge cases?"',
              '**Approach**: "I\'ll start with a brute force solution to ensure correctness, then optimize based on the pattern."',
              '**Complexity**: "Let me analyze the time and space complexity of my approach."',
              '**Testing**: "I\'ll verify with standard cases, edge cases, and stress test with large inputs."'
            ];
          }

          // Generate common mistakes based on pattern
          function generateCommonMistakes(primaryPattern) {
            const mistakes = {
              'Sliding Window': [
                '**Window Boundary Errors**: Forgetting to update window start/end correctly, leading to incorrect window size',
                '**Premature Shrinking**: Shrinking the window before recording the result, missing valid windows',
                '**Hash Map Cleanup**: Not removing elements from frequency map when shrinking window',
                '**Integer Overflow**: Not handling potential overflow when calculating window sum for large numbers',
                '**Edge Case**: Not handling empty input or single element arrays correctly'
              ],
              'Two Pointers': [
                '**Pointer Initialization**: Starting pointers at wrong positions (e.g., both at start instead of start/end)',
                '**Movement Logic**: Moving both pointers simultaneously when only one should move',
                '**Duplicate Handling**: Not skipping duplicates in sorted array, leading to duplicate results',
                '**Sorted Assumption**: Forgetting to sort the array when the algorithm requires it',
                '**Boundary Check**: Not validating pointers are within array bounds before accessing elements'
              ],
              'Dynamic Programming': [
                '**Base Case**: Incorrect or missing base cases leading to wrong results for small inputs',
                '**State Definition**: Poorly defined state that doesn\'t capture all necessary information',
                '**Recurrence Relation**: Off-by-one errors in recurrence, accessing dp[i-1] when i=0',
                '**Initialization**: Not initializing DP array correctly (e.g., using 0 when it should be Infinity)',
                '**Space Optimization**: Prematurely optimizing space before getting correctness, making debugging harder'
              ],
              'BFS (Breadth-First Search)': [
                '**Visited Tracking**: Not marking nodes as visited, causing infinite loops or TLE',
                '**Visited Timing**: Marking visited when dequeuing instead of when enqueuing, exploring nodes multiple times',
                '**Level Tracking**: Incorrectly tracking levels/depth in level-order traversal',
                '**Queue Management**: Using wrong data structure (stack instead of queue), turning BFS into DFS',
                '**Boundary Checking**: Not validating coordinates/nodes before adding to queue in grid problems'
              ],
              'DFS (Depth-First Search)': [
                '**Stack Overflow**: Not considering recursion depth for deep graphs, should use iterative DFS',
                '**Visited Tracking**: For undirected graphs, not passing parent to avoid going back to parent node',
                '**Backtracking**: Forgetting to undo changes (backtrack) when exploring different paths',
                '**Base Case**: Missing or incorrect base cases in recursive DFS',
                '**Cycle Detection**: Not properly detecting cycles, leading to infinite recursion'
              ],
              'Hash Table': [
                '**Hash Collision**: Assuming hash operations are always O(1), in worst case they can be O(n)',
                '**Key Type**: Using mutable objects as keys, causing lookup failures',
                '**Existence Check**: Not checking if key exists before accessing, causing undefined behavior',
                '**Space Complexity**: Not accounting for hash map in space complexity analysis',
                '**Iteration Order**: Assuming Map/Set maintains insertion order (language-dependent)'
              ],
              'Stack': [
                '**Empty Stack**: Popping from empty stack without checking, causing runtime errors',
                '**Stack State**: Not properly maintaining stack invariant (e.g., monotonic property)',
                '**Matching Pairs**: For bracket matching, not handling case where stack is not empty at the end',
                '**Memory**: Not clearing stack between test cases or iterations, causing incorrect results',
                '**Element Order**: Confusing when to use stack vs queue based on problem requirements'
              ],
              'Binary Search': [
                '**Infinite Loop**: Incorrect mid calculation or boundary update causing infinite loop',
                '**Integer Overflow**: Using (left + right) / 2 instead of left + (right - left) / 2',
                '**Boundary Inclusion**: Off-by-one errors with left <= right vs left < right',
                '**Return Value**: Returning wrong value when target not found or boundary conditions',
                '**Predicate Function**: Incorrectly implementing the search predicate for binary search on answer'
              ],
              'Greedy': [
                '**Correctness**: Assuming greedy works without proof, when DP is actually needed',
                '**Sorting**: Sorting by wrong criteria, missing the locally optimal choice',
                '**Edge Cases**: Not handling special cases where greedy choice differs from general pattern',
                '**Multiple Criteria**: When multiple greedy criteria exist, choosing the wrong one',
                '**Validation**: Not validating that greedy choices lead to valid solution'
              ],
              'Backtracking': [
                '**State Modification**: Modifying shared state without backtracking (undo-ing changes)',
                '**Base Case**: Incorrect base case or not adding solution to results in base case',
                '**Pruning**: Missing optimization opportunities to prune invalid branches early',
                '**Duplicate Results**: Not preventing duplicate solutions in problems like permutations',
                '**Pass by Reference**: Accidentally modifying path/result array, should use copies'
              ],
              'Union-Find': [
                '**Path Compression**: Not implementing path compression, degrading to O(n) operations',
                '**Union by Rank**: Not implementing union by rank/size, creating unbalanced trees',
                '**Initialization**: Not properly initializing parent array (parent[i] = i)',
                '**Connected Components**: Incorrectly counting components after union operations',
                '**Find Implementation**: Not recursively compressing path in find operation'
              ],
              'Trie': [
                '**Memory Leaks**: Not properly managing TrieNode memory allocation',
                '**End Marker**: Forgetting to mark end of word, causing prefix-only matches',
                '**Node Initialization**: Not initializing children map/array in TrieNode',
                '**Case Sensitivity**: Not handling case sensitivity correctly when required',
                '**Character Range**: Assuming only lowercase letters when input can be wider'
              ],
              'Bit Manipulation': [
                '**Operator Precedence**: Bitwise operators have lower precedence than comparison operators',
                '**Signed vs Unsigned**: Not considering signed bit for negative numbers',
                '**Bit Width**: Assuming 32-bit integers when problem might require 64-bit',
                '**Off-by-One**: Bit shifting by wrong amount, e.g., 1 << i vs 1 << (i-1)',
                '**AND vs OR**: Confusing bitwise AND (&) with logical AND (&&)'
              ]
            };
            
            return mistakes[primaryPattern] || [
              '**Off-by-one Errors**: Carefully check loop boundaries and array indices',
              '**Edge Cases**: Test with empty input, single element, and boundary values',
              '**Null Checks**: Validate input is not null or undefined before processing',
              '**Type Coercion**: Be explicit with type conversions in JavaScript/TypeScript',
              '**Complexity**: Verify your solution meets the expected time/space complexity'
            ];
          }

          // OpenAI API call (optional enhancement)
          async function enhanceWithOpenAI(baseCard) {
            if (!hasOpenAI) return null;
            
            const apiKey = process.env.OPENAI_API_KEY;
            const prompt = 'You are a coding interview mentor. Given this learning card for a DSA problem, enhance the "Key Insight" section with a more detailed, insightful explanation that reveals the "aha moment" of the solution. Keep it concise but illuminating.\n\nSolution code:\n```\n' + 
              solutionContent.substring(0, 1000) + 
              '\n```\n\nCurrent learning card:\n' + 
              baseCard + 
              '\n\nProvide ONLY the enhanced "Key Insight" section content (the text after the ### ðŸ§  Key Insight heading), nothing else.';

            const requestData = JSON.stringify({
              model: 'gpt-4o-mini',
              messages: [
                { role: 'system', content: 'You are a helpful coding mentor who provides concise, insightful explanations.' },
                { role: 'user', content: prompt }
              ],
              max_tokens: 300,
              temperature: 0.7
            });

            return new Promise((resolve) => {
              const options = {
                hostname: 'api.openai.com',
                port: 443,
                path: '/v1/chat/completions',
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': 'Bearer ' + apiKey,
                  'Content-Length': requestData.length
                },
                timeout: 10000
              };

              const req = https.request(options, (res) => {
                let data = '';
                res.on('data', (chunk) => { data += chunk; });
                res.on('end', () => {
                  try {
                    const response = JSON.parse(data);
                    resolve(response.choices[0].message.content.trim());
                  } catch (e) {
                    resolve(null);
                  }
                });
              });

              req.on('error', () => resolve(null));
              req.on('timeout', () => { req.destroy(); resolve(null); });
              req.write(requestData);
              req.end();
            });
          }

          // Main execution
          (async () => {
            const detected = detectPatterns(solutionContent);
            const complexity = extractComplexity(solutionContent);
            const inferred = inferComplexity(solutionContent, detected);
            
            const timeComplexity = complexity.time || inferred.time;
            const spaceComplexity = complexity.space || inferred.space;
            
            const keyInsight = generateKeyInsight(detected.primary, solutionContent);
            const relatedProblems = generateRelatedProblems(detected.primary);
            const interviewTips = generateInterviewTips(detected.primary);
            const commonMistakes = generateCommonMistakes(detected.primary);
            
            // Build base learning card
            let learningCard = '## ðŸ“š Coding Challenge Learning Card\n\n' +
              '| Property | Value |\n' +
              '|----------|-------|\n' +
              '| **Platform** | ' + platform + ' |\n' +
              '| **Problem** | ' + (problemNum ? problemNum + ' - ' : '') + problemName + ' |\n' +
              '| **Difficulty** | ' + difficulty + ' |\n' +
              '| **File** | `' + filePath + '` |\n\n' +
              '---\n\n' +
              '### ðŸŽ¯ Pattern Analysis\n\n' +
              '**Primary Pattern:** ' + detected.primary + '\n\n' +
              (detected.secondary.length > 0 ? '**Secondary Patterns:** ' + detected.secondary.join(', ') + '\n\n' : '') +
              (detected.techniques.length > 0 ? '**Techniques Used:** ' + detected.techniques.join(', ') + '\n\n' : '') +
              '**Data Structures:** ' + (detected.dataStructures.join(', ') || 'Standard primitives') + '\n\n' +
              '**Complexity:**\n' +
              '- **Time:** ' + timeComplexity + '\n' +
              '- **Space:** ' + spaceComplexity + '\n\n' +
              '---\n\n' +
              '### ðŸ§  Key Insight\n\n' +
              keyInsight + '\n\n' +
              '---\n\n' +
              '### ðŸ“– Related Problems to Practice\n\n' +
              'After solving this problem, try these related problems that use similar patterns:\n\n' +
              '| Problem | Title | Relationship |\n' +
              '|---------|-------|--------------|\n' +
              relatedProblems.slice(0, 5).map(p => {
                const link = p.id ? '[' + p.id + '](https://leetcode.com/problems/' + p.name.toLowerCase().replace(/[^a-z0-9]+/g, '-') + ')' : 'LeetCode';
                return '| ' + link + ' | ' + p.name + ' | ' + p.level + ' |';
              }).join('\n') + '\n\n' +
              '---\n\n' +
              '### ðŸ’¡ Interview Tips\n\n' +
              "Here's how to approach this problem in an interview setting:\n\n" +
              interviewTips.join('\n\n') + '\n\n' +
              '---\n\n' +
              '### âš ï¸ Common Mistakes\n\n' +
              'Watch out for these pattern-specific mistakes:\n\n' +
              commonMistakes.map((mistake, i) => (i + 1) + '. ' + mistake).join('\n') + '\n\n' +
              '---\n\n' +
              '### ðŸŽ“ How to Use This Card\n\n' +
              '- **Review** the pattern analysis to understand the core approach\n' +
              '- **Memorize** the key insight - it\'s the "aha!" moment that unlocks similar problems  \n' +
              '- **Practice** the related problems to reinforce pattern recognition\n' +
              '- **Rehearse** the interview tips out loud to build communication skills\n' +
              '- **Avoid** the common mistakes by being aware of them during implementation\n\n' +
              '---\n\n' +
              '*ðŸ¤– Generated by DSA Mentor â€¢ ' + (hasOpenAI ? 'Enhanced with AI' : 'Heuristics-based analysis') + '*';

            // Try to enhance with OpenAI if available
            if (hasOpenAI) {
              console.log('Attempting to enhance with OpenAI...');
              const enhancedInsight = await enhanceWithOpenAI(learningCard);
              if (enhancedInsight) {
                // Replace the key insight section
                learningCard = learningCard.replace(
                  /### ðŸ§  Key Insight\n\n[\s\S]*?\n\n---/,
                  '### ðŸ§  Key Insight\n\n' + enhancedInsight + '\n\n---'
                );
                console.log('Successfully enhanced with OpenAI');
              } else {
                console.log('OpenAI enhancement failed, using heuristics');
              }
            }

            // Write the learning card
            fs.writeFileSync('learning-card.md', learningCard);
            console.log('Learning card generated successfully');
            console.log('Primary pattern detected:', detected.primary);
            console.log('Data structures:', detected.dataStructures.join(', '));
          })();
          SCRIPT_EOF

      - name: Post Learning Card Comment
        if: steps.problem.outputs.found == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            let learningCard = '## ðŸ“š Coding Challenge Learning Card\n\n';
            learningCard += '**Problem analysis pending...**\n\n';

            try {
              learningCard = fs.readFileSync('learning-card.md', 'utf8');
            } catch (e) {
              console.log('Could not read learning card:', e.message);
            }

            // Check if we already commented on this PR
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(comment =>
              comment.user.login === 'github-actions[bot]' &&
              comment.body.includes('ðŸ“š Coding Challenge Learning Card')
            );

            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: learningCard
              });
              console.log('Updated existing Coding Challenge Learning Card comment');
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: learningCard
              });
              console.log('Created new Coding Challenge Learning Card comment');
            }
