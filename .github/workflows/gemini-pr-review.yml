name: Gemini Code Review
on:
  pull_request:
    types: [opened, synchronize, ready_for_review, reopened, labeled]

permissions:
  contents: read
  pull-requests: write

jobs:
  review:
    runs-on: ubuntu-latest
    if: github.actor == 'pertrai1' && contains(github.event.pull_request.labels.*.name, 'code challenge')
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Prepare Pull Request Diff
        run: |
          git diff origin/${{ github.base_ref }}...HEAD > pr_diff.txt

          # Increased limit to 300KB (Flash handles large context easily)
          DIFF_SIZE=$(wc -c < pr_diff.txt)
          if [ $DIFF_SIZE -gt 300000 ]; then
            echo "Diff is extremely large. Truncating to 300KB..."
            head -c 300000 pr_diff.txt > pr_diff_truncated.txt
            mv pr_diff_truncated.txt pr_diff.txt
          fi
          echo "Diff size: $(wc -c < pr_diff.txt) bytes"

      - name: Read Guidelines
        run: |
          # Look for a custom guidelines file (e.g., CLAUDE.md or CONTRIBUTING.md)
          if [ -f "CLAUDE.md" ]; then
            cat CLAUDE.md | head -c 5000 > guidelines.txt
            echo "Found CLAUDE.md guidelines"
          else
            # Default guidelines if no file exists
            echo "Focus on: Algorithm correctness, efficiency, time/space complexity, code quality, TypeScript typing strictness, and edge cases." > guidelines.txt
          fi

      - name: Generate Review with Gemini
        id: gemini
        env:
          API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          # 1. Construct the JSON payload safely using jq
          # This prevents shell injection errors and handles newlines correctly
          jq -n \
            --arg prompt "You are a DSA mentor reviewing code for learning purposes. This repository contains LeetCode solutions for practicing algorithmic problem-solving.

          REVIEW STRUCTURE:
          1. **Pattern Identification**: What algorithmic pattern does this solution use? (e.g., Sliding Window, Two Pointers, Dynamic Programming, BFS/DFS, Binary Search, etc.)

          2. **Complexity Verification**:
             - Is the stated time complexity accurate? If not, what is the correct complexity and why?
             - Is the stated space complexity accurate? If not, what is the correct complexity and why?

          3. **Key Insight**: What is the key insight or 'aha!' moment that makes this solution work? Every problem has a non-obvious trick - explain it clearly.

          4. **Edge Case Analysis**: What edge cases should be tested? Are there any edge cases the current solution might not handle correctly?

          5. **Learning Points**:
             - What similar problems use this same pattern?
             - What are common mistakes people make with this pattern?
             - What variations of this problem exist?

          6. **Code Quality**: Suggest improvements for variable naming, code structure, or readability.

          7. **Alternative Approaches**: Briefly mention 1-2 other ways to solve this problem with their trade-offs.

          Be educational - explain the 'why' behind your feedback to help the developer learn and recognize patterns in future problems." \
            --rawfile guidelines guidelines.txt \
            --rawfile diff pr_diff.txt \
            '{
              contents: [{
                parts: [
                  {text: $prompt},
                  {text: ("\n\nGUIDELINES:\n" + $guidelines)},
                  {text: "\n\nProvide your review in Markdown format with the sections outlined above.\n\nCODE DIFF:\n"},
                  {text: $diff}
                ]
              }],
              generationConfig: {
                temperature: 0.7,
                maxOutputTokens: 8192
              }
            }' > payload.json

          # 2. Call Gemini API with retry logic and model fallback
          # Models to try in order: gemini-2.5-flash, gemini-2.0-flash
          MODELS=("gemini-2.5-flash" "gemini-2.0-flash")
          MAX_RETRIES=3
          SUCCESS=false
          USED_MODEL=""

          for MODEL in "${MODELS[@]}"; do
            if [ "$SUCCESS" = true ]; then
              break
            fi

            echo "Trying model: $MODEL"
            RETRY_COUNT=0

            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              echo "  Attempt $((RETRY_COUNT + 1)) of $MAX_RETRIES..."

              # Make API request
              HTTP_CODE=$(curl -s -w "%{http_code}" -o response.json \
                -H "Content-Type: application/json" \
                -d @payload.json \
                "https://generativelanguage.googleapis.com/v1beta/models/${MODEL}:generateContent?key=$API_KEY")

              # Check if request was successful
              if [ "$HTTP_CODE" = "200" ]; then
                # Verify we got valid content
                REVIEW_TEXT=$(cat response.json | jq -r '.candidates[0].content.parts[0].text // empty')
                if [ -n "$REVIEW_TEXT" ]; then
                  echo "âœ“ Successfully received review from $MODEL"
                  SUCCESS=true
                  USED_MODEL="$MODEL"
                  break
                fi
              fi

              # Check for specific error codes
              ERROR_CODE=$(cat response.json | jq -r '.error.code // empty')
              ERROR_STATUS=$(cat response.json | jq -r '.error.status // empty')
              ERROR_MESSAGE=$(cat response.json | jq -r '.error.message // "Unknown error"')

              echo "  HTTP Code: $HTTP_CODE, Error: $ERROR_MESSAGE"

              # If it's a 503/UNAVAILABLE or 429/RESOURCE_EXHAUSTED, retry with backoff
              if [ "$HTTP_CODE" = "503" ] || [ "$HTTP_CODE" = "429" ] || \
                 [ "$ERROR_STATUS" = "UNAVAILABLE" ] || [ "$ERROR_STATUS" = "RESOURCE_EXHAUSTED" ]; then
                RETRY_COUNT=$((RETRY_COUNT + 1))
                if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                  SLEEP_TIME=$((2 ** RETRY_COUNT))  # Exponential backoff: 2, 4, 8 seconds
                  echo "  â³ API overloaded. Waiting ${SLEEP_TIME}s before retry..."
                  sleep $SLEEP_TIME
                fi
              else
                # For other errors (400, 404, etc.), don't retry - try next model
                echo "  âŒ Non-retryable error, trying next model..."
                break
              fi
            done
          done

          # 3. Handle final result
          if [ "$SUCCESS" = true ]; then
            echo "---" > review_comment.md
            echo "**ðŸ¤– Gemini Code Review** (Model: \`$USED_MODEL\`)" >> review_comment.md
            echo "" >> review_comment.md
            echo "$REVIEW_TEXT" >> review_comment.md
          else
            echo "âš ï¸ **Failed to get review from Gemini API**" > review_comment.md
            echo "" >> review_comment.md
            echo "All models failed after multiple retry attempts. This usually indicates:" >> review_comment.md
            echo "- The Gemini API is experiencing high load across all models" >> review_comment.md
            echo "- There may be an issue with your API key or quota" >> review_comment.md
            echo "" >> review_comment.md
            echo "**Last Error:**" >> review_comment.md
            echo '```' >> review_comment.md
            echo "$ERROR_MESSAGE" >> review_comment.md
            echo '```' >> review_comment.md
            echo "" >> review_comment.md
            echo "The review will be attempted again on the next PR update." >> review_comment.md
            echo "" >> review_comment.md
            echo "<details><summary>Debug Response</summary>" >> review_comment.md
            echo "" >> review_comment.md
            echo '```json' >> review_comment.md
            cat response.json | jq '.' >> review_comment.md
            echo '```' >> review_comment.md
            echo "" >> review_comment.md
            echo "</details>" >> review_comment.md
          fi

      - name: Post Comment to PR
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          gh pr comment "$PR_NUMBER" --body-file review_comment.md
