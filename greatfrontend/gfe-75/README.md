# GreatFrontEnd GFE 75

The GFE 75 is GreatFrontEnd's curated collection of 75 essential frontend coding interview questions. This directory contains solutions focusing on JavaScript fundamentals, DOM manipulation, frontend utilities, and real-world frontend engineering scenarios.

## ğŸ“Š Progress Tracker

### Status: 1 / 75 problems completed

### Progress by Category

| Category             | Completed | Total | Percentage |
| -------------------- | --------- | ----- | ---------- |
| JavaScript Utilities | 1         | 20    | 5%         |
| DOM Manipulation     | 0         | 15    | 0%         |
| Async Programming    | 0         | 12    | 0%         |
| Components           | 0         | 10    | 0%         |
| Data Structures      | 0         | 10    | 0%         |
| Algorithms           | 0         | 8     | 0%         |

## âœ… Completed Problems

### JavaScript Utilities (1/20)

- [Debounce](./javascript-utilities/debounce/) - Medium

### DOM Manipulation (0/15)

No problems completed yet

### Async Programming (0/12)

No problems completed yet

### Components (0/10)

No problems completed yet

### Data Structures (0/10)

No problems completed yet

### Algorithms (0/8)

No problems completed yet

## ğŸ¯ Learning Approach

When solving GFE 75 problems:

1. **Frontend-first mindset** - Think about real-world frontend use cases
2. **Browser APIs** - Leverage native browser capabilities when appropriate
3. **Performance** - Consider time/space complexity and browser performance
4. **Type safety** - Use TypeScript for better code quality
5. **Edge cases** - Handle browser inconsistencies and edge cases
6. **Testing** - Write comprehensive tests for utility functions

## ğŸ“š Problem Organization

Problems are organized by category to facilitate pattern recognition:

```text
gfe-75/
â”œâ”€â”€ javascript-utilities/    # debounce, throttle, curry, memoize, etc.
â”œâ”€â”€ dom-manipulation/         # querySelector, event delegation, virtual DOM, etc.
â”œâ”€â”€ async-programming/        # promises, async/await, race conditions, etc.
â”œâ”€â”€ components/               # UI components, widgets, interactive elements
â”œâ”€â”€ data-structures/          # frontend-specific data structures
â””â”€â”€ algorithms/               # sorting, searching, optimization
```

## ğŸ”§ JavaScript Utilities

Common patterns for building reusable JavaScript utilities:

- **Function transformers**: debounce, throttle, memoize, curry
- **Object utilities**: deep clone, deep equal, get/set nested values
- **Array utilities**: flatten, chunk, unique, intersection
- **Type checking**: isPlainObject, isArray, isPrimitive
- **String utilities**: template parser, camelCase, kebabCase

## ğŸŒ DOM Manipulation

Essential skills for working with the Document Object Model:

- **Selection**: querySelector implementations, tree traversal
- **Events**: event delegation, custom events, event emitter
- **Rendering**: virtual DOM, efficient updates, reconciliation
- **Forms**: validation, serialization, field management
- **Performance**: requestAnimationFrame, IntersectionObserver

## âš¡ Async Programming

Mastering asynchronous JavaScript patterns:

- **Promises**: Promise.all, Promise.race, Promise.allSettled
- **Async utilities**: retry logic, timeout, concurrent execution
- **Data fetching**: caching, deduplication, pagination
- **State management**: loading states, error handling
- **Cancellation**: AbortController, cleanup logic

## ğŸ¨ Components

Building interactive UI components:

- **Interactive elements**: accordions, tabs, modals, tooltips
- **Data visualization**: charts, graphs, progress bars
- **Forms**: autocomplete, typeahead, multi-select
- **Lists**: infinite scroll, virtualization, drag-and-drop
- **Media**: image carousel, video player, gallery

## ğŸ“¦ Data Structures

Frontend-specific data structure implementations:

- **Cache**: LRU cache, LFU cache, memoization cache
- **Tree**: DOM tree operations, tree flattening
- **Graph**: dependency resolution, DOM hierarchy
- **Queue**: event queue, task scheduler
- **Stack**: undo/redo, history management

## ğŸš€ Best Practices

- **Clean code**: Write readable, maintainable solutions
- **Browser compatibility**: Consider cross-browser differences
- **Memory leaks**: Clean up event listeners and timers
- **Accessibility**: Consider a11y in component implementations
- **Security**: Validate inputs, prevent XSS
- **Testing**: Unit tests with Vitest/Jest

## ğŸ”— Cross-References

Many GFE 75 problems build upon fundamental computer science concepts. When applicable, solutions may reference:

- Related LeetCode problems in this repository
- Blind 75 patterns that apply to frontend scenarios
- Real-world library implementations (Lodash, Underscore, etc.)

## ğŸ“– Resources

- [GreatFrontEnd Platform](https://www.greatfrontend.com/)
- [GreatFrontEnd Questions](https://www.greatfrontend.com/questions)
- [Frontend Interview Handbook](https://www.frontendinterviewhandbook.com/)
- [MDN Web Docs](https://developer.mozilla.org/)

## ğŸ’¡ Tips for Success

1. **Understand the use case** - Why would this be needed in a real application?
2. **Start simple** - Get a working solution first, then optimize
3. **Consider edge cases** - null/undefined, empty inputs, browser quirks
4. **Think about performance** - Memory usage, time complexity, browser reflows
5. **Write tests** - Ensure your solution handles various scenarios
6. **Review implementations** - Study how popular libraries solve similar problems

---

_Last updated: [Date]_
